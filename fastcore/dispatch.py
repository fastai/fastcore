# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/04_dispatch.ipynb (unless otherwise specified).


from __future__ import annotations


__all__ = ['FastFunction', 'FastDispatcher', 'typedispatch', 'cast', 'retain_meta', 'default_set_meta', 'retain_type',
           'retain_types', 'explode_types']

# Cell
#nbdev_comment from __future__ import annotations
from .imports import *
from .foundation import *
from .utils import *
from .meta import delegates

from collections import defaultdict
from plum import Function, Dispatcher

# Cell
def _eval_annotations(f):
    "Evaluate future annotations before passing to plum to support backported union operator `|`"
    f = copy_func(f)
    for k, v in type_hints(f).items(): f.__annotations__[k] = Union[v] if isinstance(v, tuple) else v
    return f

# Cell
def _pt_repr(o):
    "Concise repr of plum types"
    n = type(o).__name__
    if n == 'Tuple': return f"{n.lower()}[{','.join(_pt_repr(t) for t in o._el_types)}]"
    if n == 'List': return f'{n.lower()}[{_pt_repr(o._el_type)}]'
    if n == 'Dict': return f'{n.lower()}[{_pt_repr(o._key_type)},{_pt_repr(o._value_type)}]'
    if n in ('Sequence','Iterable'): return f'{n}[{_pt_repr(o._el_type)}]'
    if n == 'VarArgs': return f'{n}[{_pt_repr(o.type)}]'
    if n == 'Union': return '|'.join(sorted(t.__name__ for t in (o.get_types())))
    assert len(o.get_types()) == 1
    return o.get_types()[0].__name__

# Cell
class FastFunction(Function):
    def __repr__(self):
        return '\n'.join(f"{f.__name__}: ({','.join(_pt_repr(t) for t in s.types)}) -> {_pt_repr(r)}"
                         for s, (f, r) in self.methods.items())

    @delegates(Function.dispatch)
    def dispatch(self, f=None, **kwargs): return super().dispatch(_eval_annotations(f), **kwargs)

    def __getitem__(self, ts):
        "Return the most-specific matching method with fewest parameters"
        ts = L(ts)
        nargs = min(len(o) for o in self.methods.keys())
        while len(ts) < nargs: ts.append(object)
        return self.invoke(*ts)

# Cell
class FastDispatcher(Dispatcher):
    def _get_function(self, method, owner):
        "Adapted from `Dispatcher._get_function` to use `FastFunction`"
        name = method.__name__
        if owner:
            if owner not in self._classes: self._classes[owner] = {}
            namespace = self._classes[owner]
        else: namespace = self._functions
        if name not in namespace: namespace[name] = FastFunction(method, owner=owner)
        return namespace[name]

    @delegates(Dispatcher.__call__, but='method')
    def __call__(self, f, **kwargs): return super().__call__(_eval_annotations(f), **kwargs)

    def _to(self, cls, nm, f, **kwargs):
        nf = copy_func(f)
        nf.__qualname__ = f'{cls.__name__}.{nm}' # plum uses __qualname__ to infer f's owner
        pf = self(nf, **kwargs)
        # plum uses __set_name__ to resolve a plum.Function's owner
        # since we assign after class creation, __set_name__ must be called directly
        # source: https://docs.python.org/3/reference/datamodel.html#object.__set_name__
        pf.__set_name__(cls, nm)
        pf = pf.resolve()
        setattr(cls, nm, pf)
        return pf

    def to(self, cls):
        "Decorator: dispatch `f` to `cls.f`"
        def _inner(f, **kwargs):
            nm = f.__name__
            # check __dict__ to avoid inherited methods but use getattr so pf.__get__ is called, which plum relies on
            if nm in cls.__dict__:
                pf = getattr(cls, nm)
                if not hasattr(pf, 'dispatch'): pf = self._to(cls, nm, pf, **kwargs)
                pf.dispatch(f)
            else: pf = self._to(cls, nm, f, **kwargs)
            return pf
        return _inner

typedispatch = FastDispatcher()

# Cell
#nbdev_comment _all_=['cast']

# Cell
def retain_meta(x, res, as_copy=False):
    "Call `res.set_meta(x)`, if it exists"
    if hasattr(res,'set_meta'): res.set_meta(x, as_copy=as_copy)
    return res

# Cell
def default_set_meta(self, x, as_copy=False):
    "Copy over `_meta` from `x` to `res`, if it's missing"
    if hasattr(x, '_meta') and not hasattr(self, '_meta'):
        meta = x._meta
        if as_copy: meta = copy(meta)
        self._meta = meta
    return self

# Cell
@typedispatch
def cast(x, typ):
    "cast `x` to type `typ` (may also change `x` inplace)"
    res = typ._before_cast(x) if hasattr(typ, '_before_cast') else x
    if risinstance('ndarray', res): res = res.view(typ)
    elif hasattr(res, 'as_subclass'): res = res.as_subclass(typ)
    else:
        try: res.__class__ = typ
        except: res = typ(res)
    return retain_meta(x, res)

# Cell
def retain_type(new, old=None, typ=None, as_copy=False):
    "Cast `new` to type of `old` or `typ` if it's a superclass"
    # e.g. old is TensorImage, new is Tensor - if not subclass then do nothing
    if new is None: return
    assert old is not None or typ is not None
    if typ is None:
        if not isinstance(old, type(new)): return new
        typ = old if isinstance(old,type) else type(old)
    # Do nothing the new type is already an instance of requested type (i.e. same type)
    if typ==NoneType or isinstance(new, typ): return new
    return retain_meta(old, cast(new, typ), as_copy=as_copy)

# Cell
def retain_types(new, old=None, typs=None):
    "Cast each item of `new` to type of matching item in `old` if it's a superclass"
    if not is_listy(new): return retain_type(new, old, typs)
    if typs is not None:
        if isinstance(typs, dict):
            t = first(typs.keys())
            typs = typs[t]
        else: t,typs = typs,None
    else: t = type(old) if old is not None and isinstance(old,type(new)) else type(new)
    return t(L(new, old, typs).map_zip(retain_types, cycled=True))

# Cell
def explode_types(o):
    "Return the type of `o`, potentially in nested dictionaries for thing that are listy"
    if not is_listy(o): return type(o)
    return {type(o): [explode_types(o_) for o_ in o]}